<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"><title>NuclearJS</title><link href="output.css" type="text/css" rel="stylesheet" media="screen,projection"></head><body><div class="section pad-bot red darken-2" id="index-banner"><div class="container"><h1 class="header center white-text">NuclearJS</h1><div class="row center"><h5 class="header col s12 light white-text">Reactive Flux built with ImmutableJS data structures.</h5></div><div class="row center"><iframe src="https://ghbtns.com/github-btn.html?user=optimizely&amp;repo=nuclear-js&amp;type=star&amp;count=true&amp;size=large" frameborder="0" scrolling="0" width="140px" height="30px"></iframe></div></div></div><div class="container"><div class="section tour-section"><div class="row"><div class="col s12 m12 l5 valign-wrapper"><div class="valign"><h4 class="red-text tour-section--title">Simple &amp; Elegant Flux</h4><h5 class="tour-section--bullet-title">Singular application state</h5><p class="tour-section--bullet-item">All application state is stored in one Immutable Map - think <a href="https://github.com/swanodette/om">Om</a>.</p><p class="tour-section--bullet-item">Stores are stateless and declarative.  Each store in Nuclear specifies the initial state and how subsequent actions mutate that state for a section of application.</p><h5 class="tour-section--bullet-title">First class support for derived data</h5><p class="tour-section--bullet-item">Compose and transform your data together statelessly and efficiently using a functional lens concept called <strong>Getters</strong>. This pattern eliminates the confusing <code>store.waitsFor</code> method found in other Flux implementations.</p><h5 class="tour-section--bullet-title">Reactive</h5><p class="tour-section--bullet-item">Nuclear can observe and react to any granularity of state change, including derived state through Getters.</p><p class="tour-section--bullet-item">Mixins and higher order components make automatic data binding between Nuclear and frameworks such as React and VueJS a breeze!</p><h5 class="tour-section--bullet-title">Efficient</h5><p class="tour-section--bullet-item">Thanks to immutable state, all change detection can be done with a constant time triple equals (<code>===</code>) check.</p></div></div><div class="col s12 m12 l6 offset-l1 tour-section--example"><div><div class="browser-component"><div class="browser-component--top"><div class="browser-component--top-left"></div><div class="browser-component--top-middle"></div><div class="browser-component--top-right"></div></div><div class="browser-component--content"><div style="min-height:200px;"><div class="example-select-wrapper">Filter by type: <select class="browser-default"><option value="all">All</option><option value="food">Food</option><option value="clothes">Clothes</option></select></div><table class="bordered"><thead><tr><th data-field="id">Name</th><th data-field="name">Type</th><th data-field="price">Price</th></tr></thead><tbody><tr><td>banana</td><td>food</td><td>1</td></tr><tr><td>doritos</td><td>food</td><td>4</td></tr><tr><td>shirt</td><td>clothes</td><td>15</td></tr><tr><td>pants</td><td>clothes</td><td>20</td></tr></tbody></table><div class="example-step"><h6 class="example-step--title valign">User action updates application state</h6><div class="highlighted-code"><pre>
<code class="json"><strong>AppState </strong>{
  &quot;typeFilter&quot;: null,
  &quot;items&quot;: [
    {&quot;type&quot;: &quot;food&quot;,&quot;name&quot;: &quot;banana&quot;,&quot;price&quot;: 1},
    {&quot;type&quot;: &quot;food&quot;,&quot;name&quot;: &quot;doritos&quot;,&quot;price&quot;: 4},
    {&quot;type&quot;: &quot;clothes&quot;,&quot;name&quot;: &quot;shirt&quot;,&quot;price&quot;: 15},
    {&quot;type&quot;: &quot;clothes&quot;,&quot;name&quot;: &quot;pants&quot;,&quot;price&quot;: 20}
  ]
}</code></pre></div></div><div class="example-step"><h6 class="example-step--title">Getters compose and transform application state reactively notifying components of any changes.</h6><div class="highlighted-code"><pre>
<code class="json"><strong>filteredItems Getter </strong>[
  {&quot;type&quot;: &quot;food&quot;,&quot;name&quot;: &quot;banana&quot;,&quot;price&quot;: 1},
  {&quot;type&quot;: &quot;food&quot;,&quot;name&quot;: &quot;doritos&quot;,&quot;price&quot;: 4},
  {&quot;type&quot;: &quot;clothes&quot;,&quot;name&quot;: &quot;shirt&quot;,&quot;price&quot;: 15},
  {&quot;type&quot;: &quot;clothes&quot;,&quot;name&quot;: &quot;pants&quot;,&quot;price&quot;: 20}
]</code></pre></div></div></div></div></div></div></div></div></div></div><div class="tour-section--bg"><div class="container"><div class="section tour-section"><div class="row"><div class="col s12 m12 l12"><h4 class="red-text tour-section--title">Usage:</h4></div></div><div id="usage-example"></div></div></div></div><div class="container"><div class="section tour-section"><div class="row"><div class="col s12 m12 l6 tour-section--info"><h4 class="red-text tour-section--title">Tested &amp; Production Ready</h4><h5 class="tour-section--bullet-title">Maintained by Optimizely</h5><p class="tour-section--bullet-item">Optimizely has been using NuclearJS in production since 2014 and will offer long term support and a stable API.</p><h5 class="tour-section--bullet-title">Easy debugging</h5><p class="tour-section--bullet-item">With NuclearJS&#x27; built in logger you can inspect your application state from the beginning of time. NuclearJS makes tracking down difficult bugs a breeze, allowing you to focus more time writing code.</p><h5 class="tour-section--bullet-title">Testable</h5><p class="tour-section--bullet-item">When building with NuclearJS there is never a question of &quot;How do I test this?&quot;. There are prescribed testing strategies for every type of thing you will build with NuclearJS.</p><h5 class="tour-section--bullet-title">Prescribed code organization structure</h5><p>For large codebases the prescribed way of organization is to group all stores, actions and getters of the same domain in a module.</p><p>This method of code organization is extremely portable, making it almost trivial to refactor, split code into multiple bundles and create contracts between modules.</p><p>In fact, Optimizely&#x27;s codebase has over 50 modules and is growing everyday.  Using this pattern makes it easy for teams to consume other teams modules, leading to great code reusability.</p></div><div class="col s12 m12 l5 offset-l1 tour-section--example"><img src="img/debug_console.jpg" width="750px" alt=""></div></div></div></div><script src="app.js"></script></body></html>
